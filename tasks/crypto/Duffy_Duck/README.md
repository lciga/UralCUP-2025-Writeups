# Duffy Duck | medium | crypto

## Информация

> Только свистни, он появится...

## Деплой

```sh
cd deploy
docker compose up --build -d
```

## Описание

Сервер реализует протокол Diffie-Hellman для обмена ключами, но использует группу с составным порядком

## Решение

После подключения к серверу получаем большое простое $p$, генератор $g$, и публичный ключ сервера $A = g^a \mod p$, что похоже на алгоритм Diffie-Hellman. Мы отправляем свой публичный ключ $B = g^b \mod p$, сервер в свою очередь возвращает IV и ciphertext — флаг, зашифрованный AES-CBC с ключом из общего секрета $S = B^a \mod p = g^{ab} \mod p$.

Подключаемся к серверу и получаем:
```
p = 32317006071311007300338913926423828248817941241140239112842009751400741706634354222619689417363569347117901737909704191754605873209195028853758986185622153212175412514901774520270235796078236248884246189477587641105928646099411723245426622522193230540919037680524235519125679715870117001058055877651038861847280257976054903569732561526167081339361799541336476559160368317896729073178384589680639671900977202194168647225871031411336429319536193471636533209717077448227988588565369208645296636077250268955505928362751121174096972998068410554359584866583291642136218231078990999448652468262416972035911852507045361090559
g = 2
A = 31995317331758339992060997190603642830826808707649112499383052528160908727417492473872655903227196198153373870259935840266508809826816957239219715143021487784202841719873575801817126624612407725234714400811943637647548714366718204344462676254333765992183533743871468328801947461010629788596785878040294146182728559816674425854327943947858629016404898595798888512915920867453037016802204051806148837075766344988437300709552271615294456481857201949056977394694530261299579054352602822240376230676400080205145908830893795149063468304035454328327464504752034916054203213486845457551318472750730391687507217024725226002401
```
p — это 2048-битное простое (из стандарта FFDHE-2048). g=2 — типичный генератор. A — публичный ключ сервера. Выберем b, например, 42, потому что B = 40000000000 hex = $2^42$, а $g = 2$, и $2^{42} < p$, так что $B = g^b \mod p = g^b$. Это упрощает дело — $b$ маленькое, отправим серверу, на что получим:
```
IV (hex): e0a9fb29e3c44b84f4bcc3e5cbccb96e
Ciphertext (hex): fbf2d7da0c36b72994c84086bfdab62f8f0ef9874445cf30323cca26e3e0a21d0faa236047b77908e945d2f1cc0a812d
```

В DH безопасность основана на сложности дискретного логарифма (DLP). Но здесь, поскольку $b$ маленькое, можно вычислить $S = A^b \mod p$ без вычисления $a$. Но чтобы показать Pohlig-Hellman необходимо проверить порядок $g$:
```py
import sympy
p = 32317006071311007300338913926423828248817941241140239112842009751400741706634354222619689417363569347117901737909704191754605873209195028853758986185622153212175412514901774520270235796078236248884246189477587641105928646099411723245426622522193230540919037680524235519125679715870117001058055877651038861847280257976054903569732561526167081339361799541336476559160368317896729073178384589680639671900977202194168647225871031411336429319536193471636533209717077448227988588565369208645296636077250268955505928362751121174096972998068410554359584866583291642136218231078990999448652468262416972035911852507045361090559
n = p - 1
q = n // 2
order_test = pow(2, q, p)
factors = sympy.factorint(n)
print(factors)
print(order_test)
```
Получим:
```
{2: 1, 16158503035655503650169456963211914124408970620570119556421004875700370853317177111309844708681784673558950868954852095877302936604597514426879493092811076606087706257450887260135117898039118124442123094738793820552964323049705861622713311261096615270459518840262117759562839857935058500529027938825519430923640128988027451784866280763083540669680899770668238279580184158948364536589192294840319835950488601097084323612935515705668214659768096735818266604858538724113994294282684604322648318038625134477752964181375560587048486499034205277179792433291645821068109115539495499724326234131208486017955926253522680545279: 1}
1
```
Pohlig-Hellman здесь не дает преимущества, потому что порядок простой. Но поскольку $b$ маленькое, я могу вычислить $S = A^b \mod p$:
```py
p = 32317006071311007300338913926423828248817941241140239112842009751400741706634354222619689417363569347117901737909704191754605873209195028853758986185622153212175412514901774520270235796078236248884246189477587641105928646099411723245426622522193230540919037680524235519125679715870117001058055877651038861847280257976054903569732561526167081339361799541336476559160368317896729073178384589680639671900977202194168647225871031411336429319536193471636533209717077448227988588565369208645296636077250268955505928362751121174096972998068410554359584866583291642136218231078990999448652468262416972035911852507045361090559
A = 31995317331758339992060997190603642830826808707649112499383052528160908727417492473872655903227196198153373870259935840266508809826816957239219715143021487784202841719873575801817126624612407725234714400811943637647548714366718204344462676254333765992183533743871468328801947461010629788596785878040294146182728559816674425854327943947858629016404898595798888512915920867453037016802204051806148837075766344988437300709552271615294456481857201949056977394694530261299579054352602822240376230676400080205145908830893795149063468304035454328327464504752034916054203213486845457551318472750730391687507217024725226002401
b = 42
S = pow(A, b, p)
print(S)
```
Получаем S:
```
5424383347451100838417682881039161043079021963415632655236577850315155494623813236125639904040621107496440790552674283130321727576986353415375204471880217426910902185567069015414556862840023557624456713925369082080081322879363476867241682909283206401716139729855702285261140856363468634713251898550410293755582846518046123668963267680529749348007695185570811890482386664813599000238439853609674334092045912449543711363055377511303230321666833001117621545763069349899429918055361491616456334682883214100728152946409162693348206333270556941810071072222689459958388559762059624467636369225252897023110950107527250901219
```
Ключ - первые 16 байт str(S), со сдвигом \x00 слева:
```py
S = 5424383347451100838417682881039161043079021963415632655236577850315155494623813236125639904040621107496440790552674283130321727576986353415375204471880217426910902185567069015414556862840023557624456713925369082080081322879363476867241682909283206401716139729855702285261140856363468634713251898550410293755582846518046123668963267680529749348007695185570811890482386664813599000238439853609674334092045912449543711363055377511303230321666833001117621545763069349899429918055361491616456334682883214100728152946409162693348206333270556941810071072222689459958388559762059624467636369225252897023110950107527250901219
S_str = str(S)
key_str = S_str[:16]
key = key_str.encode().rjust(16, b'\x00')
print(key)
```
Получим ключ `5424383347451100` и используем его для дешифровки:
```py
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

key = b'5424383347451100'
iv = bytes.fromhex('e0a9fb29e3c44b84f4bcc3e5cbccb96e')
ciphertext = bytes.fromhex('fbf2d7da0c36b72994c84086bfdab62f8f0ef9874445cf30323cca26e3e0a21d0faa236047b77908e945d2f1cc0a812d')

backend = default_backend()
cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=backend)
decryptor = cipher.decryptor()
plaintext = decryptor.update(ciphertext) + decryptor.finalize()

flag = plaintext.rstrip(b"\x00").decode()
print(f"Flag: {flag}")
```

## Флаг

`UralCTF{L1f3_15_l1K3_4_hURr1c4N3}`

