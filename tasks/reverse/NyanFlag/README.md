# NyanFlag | Easy | Reverse

## Информация

>Котик-проказник нахулиганил и съел твой флаг!

## Выдать участникам

[Архив](public/nyanflag.tar.gz)

## Описание

Отладка программы через старый DOS-отладчик, прыжок до функции дешифровки / дизассемблирование в режиме 16-бит с переписыванием функции дешифровки.

## Решение

Открытие в утилите статического анализа позволяет понять, что это не .ELF и не .EXE, программа не содержит никакой сигнатуры. Пробуем запустить под DOS.

Программа выводит ASCII-арт и завершает работу. 
[Image](images/image1.jpg)
На деле внутри содержится функция дешифровки и вывода флага, которую видно в любом отладчике под DOS, например, AFD.
Открываем в отладчике.
[Image](images/image2.jpg)
При отладке в AFD спускаемся до инструкции CS:0115 – она и всё, следующее далее и входящее в функцию дешифровки, обходятся при обычном выполнении.
[Image](images/image3.jpg)
F1 – заходим, выполняем, и когда программа вошла в цикл дешифровки, спускаемся до дампа (F8). Смотрим – почти в самом конце начинает появляться флаг. Снова поднимаемся до инструкций (F7) и продолжаем выполнение в цикле (F1), пока флаг не проявится полностью.
[Image](images/image4.jpg)


Имеется второй вариант решения - дизассемблирование и переписывание функции дешифровки. Он менее предпочтителен, потому что IDA не отделяет ASCII-арт с XOR-ключом – визуально заметить этот восьмибайтовый ключ сложно.
[Image](images/image5.jpg)
IDA без расширения файла не сможет определить разрядность. Либо переименовываем файл в NYANFLAG.COM до загрузки, либо выбираем дизассемблирование в режиме 16-бит.

Видим зашифрованный флаг, загружаемый, как код, а не db данные. 
[Image](images/image6.jpg)
Из функции дешифровки также видно, что имеется паттерн - каждый байт зашифрованного флага XOR'ится с байтом ключа (сам ключ - 8 байт) по такому паттерну: 0,1,2,3,4,5,6,7,6,5,4,3,2,1,0,1,2,3,4,5,6,7,6,5,4,3,2,1,0,1,2.
[Image](images/image7.jpg)

Воспроизводим функцию и получаем флаг.
[Код](solve/code.py)

## Флаг

`UralCTF{d0s_d3bugg3r_vs_k1tt3n}`
